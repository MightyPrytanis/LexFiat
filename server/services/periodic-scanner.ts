// @CYRANO_REUSABLE: Periodic scanning service for automated component discovery
import { ComponentScannerService } from './component-scanner.js';
import { ComponentDocumentationService } from './component-documentation.js';
import { db } from '../db.js';
import { reusableComponents, componentScanReports } from '../../shared/schema.js';
import { eq, gte } from 'drizzle-orm';

export interface PeriodicScanConfig {
  enabled: boolean;
  intervalHours: number;
  scanType: 'full_scan' | 'incremental' | 'security_scan';
  autoGenerateDocs: boolean;
  notificationThreshold: number; // Minimum cypher compatibility for notifications
  maxComponentsPerScan: number;
}

export interface PeriodicScanResult {
  scanId: string;
  newComponents: number;
  updatedComponents: number;
  cypherCandidates: number;
  securityIssues: number;
  docsGenerated: number;
  recommendations: string[];
}

export class PeriodicScannerService {
  private config: PeriodicScanConfig;
  private isRunning: boolean = false;
  private scanInterval: NodeJS.Timeout | null = null;

  constructor(config: Partial<PeriodicScanConfig> = {}) {
    this.config = {
      enabled: true,
      intervalHours: 24, // Daily scans by default
      scanType: 'incremental',
      autoGenerateDocs: true,
      notificationThreshold: 70,
      maxComponentsPerScan: 100,
      ...config
    };
  }

  /**
   * @CYRANO_REUSABLE: Starts the periodic scanning service
   */
  start(): void {
    if (this.isRunning) {
      console.warn('Periodic scanner is already running');
      return;
    }

    if (!this.config.enabled) {
      console.log('Periodic scanner is disabled');
      return;
    }

    console.log(`Starting periodic scanner (every ${this.config.intervalHours} hours)`);
    
    // Run initial scan
    this.performPeriodicScan().catch(console.error);

    // Schedule recurring scans
    this.scanInterval = setInterval(() => {
      this.performPeriodicScan().catch(console.error);
    }, this.config.intervalHours * 60 * 60 * 1000);

    this.isRunning = true;
  }

  /**
   * @CYRANO_REUSABLE: Stops the periodic scanning service
   */
  stop(): void {
    if (this.scanInterval) {
      clearInterval(this.scanInterval);
      this.scanInterval = null;
    }
    
    this.isRunning = false;
    console.log('Periodic scanner stopped');
  }

  /**
   * @CYRANO_REUSABLE: Performs a single periodic scan
   */
  async performPeriodicScan(): Promise<PeriodicScanResult> {
    console.log(`ðŸ”„ Starting periodic ${this.config.scanType} scan...`);
    
    const startTime = Date.now();
    const scanner = new ComponentScannerService();
    
    try {
      // Get baseline counts
      const beforeComponents = await db.select().from(reusableComponents);
      const beforeCount = beforeComponents.length;
      
      // Perform scan
      const scanId = await scanner.scanForReusableComponents(this.config.scanType);
      
      // Wait for scan completion (with timeout)
      await this.waitForScanCompletion(scanId, 300000); // 5 minute timeout
      
      // Get updated counts
      const afterComponents = await db.select().from(reusableComponents);
      const afterCount = afterComponents.length;
      
      const newComponents = Math.max(0, afterCount - beforeCount);
      const updatedComponents = Math.min(beforeCount, afterCount);
      const cypherCandidates = afterComponents.filter(c => c.cypherCompatibility >= this.config.notificationThreshold).length;
      const securityIssues = afterComponents.filter(c => 
        c.vulnerabilities && 
        Array.isArray(c.vulnerabilities) && 
        c.vulnerabilities.some((v: any) => v.severity === 'high' || v.severity === 'critical')
      ).length;

      let docsGenerated = 0;
      const recommendations: string[] = [];

      // Auto-generate documentation if enabled
      if (this.config.autoGenerateDocs && newComponents > 0) {
        try {
          const docService = new ComponentDocumentationService();
          const docPaths = await docService.generateAllDocumentation();
          docsGenerated = docPaths.length;
          console.log(`ðŸ“š Generated documentation for ${docsGenerated} components`);
        } catch (error) {
          console.warn('Failed to auto-generate documentation:', error);
          recommendations.push('Documentation generation failed - run manually');
        }
      }

      // Generate recommendations
      if (cypherCandidates > 0) {
        recommendations.push(`${cypherCandidates} components are good candidates for Cyrano MCP integration`);
      }
      
      if (securityIssues > 0) {
        recommendations.push(`${securityIssues} components have security issues that need review`);
      }
      
      if (newComponents === 0 && this.config.scanType === 'incremental') {
        recommendations.push('Consider running a full scan to catch any missed components');
      }

      const scanDuration = Date.now() - startTime;
      
      const result: PeriodicScanResult = {
        scanId,
        newComponents,
        updatedComponents,
        cypherCandidates,
        securityIssues,
        docsGenerated,
        recommendations
      };

      console.log(`âœ… Periodic scan completed in ${scanDuration}ms`);
      console.log(`   ðŸ“Š New: ${newComponents}, Updated: ${updatedComponents}, Candidates: ${cypherCandidates}`);
      
      // Log significant findings
      if (newComponents > 5) {
        console.log(`ðŸŽ¯ Significant discovery: ${newComponents} new components found`);
      }
      
      if (cypherCandidates > 0) {
        console.log(`ðŸš€ Found ${cypherCandidates} potential Cyrano MCP candidates`);
      }

      return result;
    } catch (error) {
      console.error('Periodic scan failed:', error);
      throw error;
    }
  }

  /**
   * @CYRANO_REUSABLE: Waits for scan completion with timeout
   */
  private async waitForScanCompletion(scanId: string, timeoutMs: number): Promise<void> {
    const startTime = Date.now();
    const pollInterval = 2000; // 2 seconds
    
    while (Date.now() - startTime < timeoutMs) {
      const report = await db
        .select()
        .from(componentScanReports)
        .where(eq(componentScanReports.id, scanId))
        .limit(1);
        
      if (report.length > 0) {
        if (report[0].status === 'completed') {
          return;
        } else if (report[0].status === 'failed') {
          throw new Error('Scan failed');
        }
      }
      
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
    
    throw new Error('Scan timeout');
  }

  /**
   * @CYRANO_REUSABLE: Gets scan history and analytics
   */
  async getScanAnalytics(days: number = 30): Promise<{
    totalScans: number;
    successfulScans: number;
    averageComponentsFound: number;
    averageCypherCandidates: number;
    trendsData: Array<{
      date: string;
      componentsFound: number;
      cypherCandidates: number;
    }>;
  }> {
    const since = new Date();
    since.setDate(since.getDate() - days);
    
    const reports = await db
      .select()
      .from(componentScanReports)
      .where(gte(componentScanReports.createdAt, since));
    
    const totalScans = reports.length;
    const successfulScans = reports.filter(r => r.status === 'completed').length;
    const successfulReports = reports.filter(r => r.status === 'completed');
    
    const averageComponentsFound = successfulReports.length > 0
      ? Math.round(successfulReports.reduce((sum, r) => sum + r.componentsFound, 0) / successfulReports.length)
      : 0;
      
    const averageCypherCandidates = successfulReports.length > 0
      ? Math.round(successfulReports.reduce((sum, r) => sum + r.cypherCandidates, 0) / successfulReports.length)
      : 0;
    
    // Group by date for trends
    const trendsMap = new Map<string, { componentsFound: number; cypherCandidates: number; count: number }>();
    
    successfulReports.forEach(report => {
      const date = new Date(report.createdAt).toISOString().split('T')[0];
      const existing = trendsMap.get(date) || { componentsFound: 0, cypherCandidates: 0, count: 0 };
      
      existing.componentsFound += report.componentsFound;
      existing.cypherCandidates += report.cypherCandidates;
      existing.count += 1;
      
      trendsMap.set(date, existing);
    });
    
    const trendsData = Array.from(trendsMap.entries()).map(([date, data]) => ({
      date,
      componentsFound: Math.round(data.componentsFound / data.count),
      cypherCandidates: Math.round(data.cypherCandidates / data.count)
    })).sort((a, b) => a.date.localeCompare(b.date));
    
    return {
      totalScans,
      successfulScans,
      averageComponentsFound,
      averageCypherCandidates,
      trendsData
    };
  }

  /**
   * @CYRANO_REUSABLE: Generates periodic scan report
   */
  async generatePeriodicReport(): Promise<string> {
    const analytics = await this.getScanAnalytics(30);
    const components = await db.select().from(reusableComponents);
    
    const report = [];
    report.push('# LexFiat Periodic Scan Report');
    report.push(`Generated: ${new Date().toISOString()}\n`);
    
    report.push('## Scan Analytics (Last 30 Days)');
    report.push(`- Total Scans: ${analytics.totalScans}`);
    report.push(`- Successful Scans: ${analytics.successfulScans}`);
    report.push(`- Success Rate: ${analytics.totalScans > 0 ? Math.round((analytics.successfulScans / analytics.totalScans) * 100) : 0}%`);
    report.push(`- Average Components Found: ${analytics.averageComponentsFound}`);
    report.push(`- Average Cypher Candidates: ${analytics.averageCypherCandidates}\n`);
    
    report.push('## Current Component Status');
    report.push(`- Total Components: ${components.length}`);
    
    const byStatus = components.reduce((acc, comp) => {
      acc[comp.exportStatus] = (acc[comp.exportStatus] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    Object.entries(byStatus).forEach(([status, count]) => {
      report.push(`- ${status}: ${count}`);
    });
    
    const cypherCandidates = components.filter(c => c.cypherCompatibility >= 70);
    report.push(`- Cypher Candidates (70+): ${cypherCandidates.length}\n`);
    
    if (cypherCandidates.length > 0) {
      report.push('## Top Cypher Candidates');
      cypherCandidates
        .sort((a, b) => b.cypherCompatibility - a.cypherCompatibility)
        .slice(0, 10)
        .forEach((comp, index) => {
          report.push(`${index + 1}. **${comp.name}** (${comp.cypherCompatibility}/100) - ${comp.componentType}`);
        });
      report.push('');
    }
    
    if (analytics.trendsData.length > 0) {
      report.push('## Trends');
      report.push('Recent scan activity:');
      analytics.trendsData.slice(-7).forEach(trend => {
        report.push(`- ${trend.date}: ${trend.componentsFound} components, ${trend.cypherCandidates} candidates`);
      });
      report.push('');
    }
    
    report.push('## Recommendations');
    const recommendations = this.generateRecommendations(components, analytics);
    recommendations.forEach(rec => report.push(`- ${rec}`));
    
    return report.join('\n');
  }

  /**
   * @CYRANO_REUSABLE: Generates recommendations based on scan data
   */
  private generateRecommendations(components: any[], analytics: any): string[] {
    const recommendations: string[] = [];
    
    const pendingComponents = components.filter(c => c.exportStatus === 'identified');
    if (pendingComponents.length > 10) {
      recommendations.push(`${pendingComponents.length} components need documentation - consider running batch documentation generation`);
    }
    
    const cypherCandidates = components.filter(c => c.cypherCompatibility >= 70 && c.exportStatus !== 'exported');
    if (cypherCandidates.length > 0) {
      recommendations.push(`${cypherCandidates.length} high-compatibility components ready for Cyrano export`);
    }
    
    const securityIssues = components.filter(c => c.securityStatus === 'needs_review' || c.securityStatus === 'rejected');
    if (securityIssues.length > 0) {
      recommendations.push(`${securityIssues.length} components have security issues that need attention`);
    }
    
    if (analytics.successfulScans < analytics.totalScans * 0.8) {
      recommendations.push('Scan success rate is low - check for system issues or resource constraints');
    }
    
    const highReusability = components.filter(c => c.reusabilityScore >= 80);
    if (highReusability.length > 0 && highReusability.filter(c => c.exportStatus === 'exported').length === 0) {
      recommendations.push(`${highReusability.length} high-reusability components should be prioritized for export`);
    }
    
    return recommendations;
  }

  /**
   * @CYRANO_REUSABLE: Updates scanner configuration
   */
  updateConfig(newConfig: Partial<PeriodicScanConfig>): void {
    this.config = { ...this.config, ...newConfig };
    
    if (this.isRunning) {
      console.log('Restarting scanner with new configuration...');
      this.stop();
      this.start();
    }
  }

  /**
   * @CYRANO_REUSABLE: Gets current configuration
   */
  getConfig(): PeriodicScanConfig {
    return { ...this.config };
  }

  /**
   * @CYRANO_REUSABLE: Gets current status
   */
  getStatus(): { isRunning: boolean; config: PeriodicScanConfig; nextScanIn?: number } {
    const status = {
      isRunning: this.isRunning,
      config: this.config
    };
    
    // Calculate time until next scan (approximate)
    if (this.isRunning && this.scanInterval) {
      const nextScanIn = this.config.intervalHours * 60 * 60 * 1000;
      return { ...status, nextScanIn };
    }
    
    return status;
  }
}